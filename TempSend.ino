// Visual Micro is in vMicro>General>Tutorial Mode
// 
/*
	Name:       TempSend.ino
	Created:	6/28/2019 12:42:38 PM
	Author:     charles-THINK\charles
*/



/*
Name:       EvapCooler.ino
Created:	5/15/2019 12:10:52 PM
Author:     charles-THINK\charles
*/

/*  //Send script
python.exe "C:\Users\charles\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.4.2/tools/espota.py" -i "192.168.89.101" -p "8266" "--auth=" -f "o:\newcode\EvapCooler\Release\EvapCooler.ino.bin"
*/




#include <Wire.h>
#include <ESP8266WiFi.h>
#include <time.h>

#include <ArduinoOTA.h>

//Led section

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>



//Temperature
#include "mcp.h"
//Time Day and internet time
#include "nettime.h"
//OTA actions
#include "OTASetup.h"
//On webpage action log
#include "WebLog.h"



//Website
#include "output.h"
//Input/Output pins


//Config options
#include "passwords.h"

#include "8266IO.h"


extern "C" {
#include <user_interface.h>
}
//------------------------------------------------------------------------------
// File generated by LCD Assistant
// http://en.radzio.dxp.pl/bitmap_converter/
//------------------------------------------------------------------------------

const unsigned char BBCProductions2[] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xFF, 0xF3, 0xC3, 0xC3, 0xF8, 0x07, 0xE3, 0x00, 0x30, 0x10, 0x02, 0x02, 0x03, 0xF0, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xF8, 0x0F, 0x0F, 0x08, 0x3C, 0x38, 0x03, 0x06, 0x03, 0xFE, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xF8, 0x0F, 0x07, 0x8C, 0x38, 0x3C, 0x07, 0x0E, 0x03, 0xDF, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xC0, 0x0F, 0xC7, 0x9E, 0x78, 0x7C, 0x07, 0x8F, 0x03, 0xCF, 0x00,
0x00, 0x0F, 0x03, 0xFF, 0xC3, 0xF8, 0x07, 0xE3, 0x9F, 0x70, 0x7E, 0x0F, 0xDF, 0x03, 0xCF, 0x00,
0x00, 0x0F, 0x03, 0xFF, 0xC3, 0xF8, 0x03, 0xF3, 0xFF, 0xF0, 0xEF, 0x0F, 0xFF, 0x83, 0xDE, 0x00,
0x00, 0x0F, 0x03, 0xFF, 0xC3, 0xF8, 0x00, 0xF1, 0xFF, 0xE1, 0xE7, 0x0F, 0xFB, 0x83, 0xFC, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xC0, 0x01, 0xF1, 0xF3, 0xE1, 0xFF, 0x9C, 0xF3, 0xC3, 0xF8, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xFC, 0x0F, 0xE1, 0xE3, 0xC3, 0xFF, 0xDC, 0x71, 0xC3, 0xC0, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xFC, 0x07, 0x80, 0xE1, 0xC3, 0xFF, 0xFC, 0x61, 0xE3, 0xC0, 0x00,
0x00, 0x0F, 0x03, 0xC3, 0xC3, 0xFC, 0x06, 0x00, 0xC0, 0x87, 0x81, 0xE8, 0x01, 0x83, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xC0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xE0, 0xF1, 0xE0, 0x18, 0x01, 0x83, 0xF8, 0x7F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xF0, 0xF1, 0xE0, 0x78, 0x07, 0x83, 0xF8, 0x7F, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xF8, 0xE1, 0xE0, 0xFC, 0x0F, 0xC3, 0xF8, 0x79, 0xE0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xFE, 0xE1, 0xE3, 0xF0, 0x3F, 0x03, 0xC0, 0x79, 0xE0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xFF, 0xE1, 0xE3, 0xC0, 0x3C, 0x03, 0xF8, 0x79, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xDF, 0xE1, 0xE7, 0x80, 0x78, 0x03, 0xF8, 0x7F, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xCF, 0xE1, 0xE7, 0x9E, 0x79, 0xE3, 0xF8, 0x7B, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xC3, 0xE1, 0xE7, 0x9E, 0x79, 0xE3, 0xC0, 0x7B, 0xE0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xC1, 0xE1, 0xE3, 0xFE, 0x3F, 0xE3, 0xFC, 0x79, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xC0, 0xE1, 0xE3, 0xFE, 0x3F, 0xE3, 0xFC, 0x78, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xC0, 0x61, 0xE0, 0xFE, 0x0F, 0xE3, 0xFC, 0x78, 0xC0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x01, 0xE0, 0x00, 0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x07, 0xF8, 0x03, 0xC0, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0xF8, 0x0F, 0xFC, 0x0F, 0xC0, 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1E, 0x3C, 0x1F, 0xC0, 0xF1, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x1C, 0x1E, 0x0F, 0xC0, 0xF1, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x1E, 0x03, 0xC0, 0xF1, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x1E, 0x03, 0xC0, 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x3C, 0x1E, 0x03, 0xC0, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x3C, 0x1E, 0x03, 0xC0, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1E, 0x3C, 0x03, 0xC0, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x1F, 0xFC, 0x03, 0xC0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x03, 0xFC, 0x0F, 0xF8, 0x03, 0xC0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x07, 0xFC, 0x03, 0xC0, 0x03, 0xC0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

IPAddress ip(DEVICE_IP); // where .xxx is the desired IP Address
IPAddress gateway(DEVICE_GATEWAY); // set gateway to match your network
IPAddress subnet(DEVICE_SUBNET); // set subnet mask to match your
IPAddress dns1(DEVICE_DNS1);
IPAddress dns2(DEVICE_DNS2);


MCP9808 mcpInside = MCP9808();
MCP9808 mcpAttic = MCP9808();

WiFiServer server(80);


float lastTemp = 0.0f;
float lastAttic = 0.0f;
float lastWater = 0.0f;
float lastOutTemp = 0.0f;
float lastFanRPM = 0.0f;
bool pump = false;
bool fan = false;



#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
WiFiUDP udp = WiFiUDP();

unsigned long lastTime = 0;


void setup()
{
	char buffer[80];
	byte error, address;
	int nDevices;



	


	pinMode(D6, INPUT_PULLUP);

	// Show initial display buffer contents on the screen --
	// the library initializes this with an Adafruit splash screen.

	pinMode(D4, OUTPUT);

	if (!mcpInside.begin()) {
		webLog.It(-1, "MCP9808-Inside Not Found!");
	}
	else {
		webLog.It(-1, "Found MCP9808 Inside!");
	}

	nDevices = 0;
	for (address = 1; address < 127; address++)
	{
		// The i2c_scanner uses the return value of
		// the Write.endTransmisstion to see if
		// a device did acknowledge to the address.
		Wire.beginTransmission(address);
		error = Wire.endTransmission();

		if (error == 0)
		{
			sprintf(buffer, "Found Device:  %d", address);
			webLog.println(buffer);
			nDevices++;
		}
		else if (error == 4)
		{
			if (address < 16)

				Serial.println(address, HEX);
		}
	}
	if (nDevices == 0)
		webLog.println("No I2C devices found\n");
	else {

		sprintf(buffer, "Found %d devices", nDevices);
		webLog.println(buffer);

	}



	//Wire.setClock(10000);

	WiFi.persistent(false);
	WiFi.mode(WIFI_STA);

	WiFi.hostname(wifiHostName);

	WiFi.config(ip, gateway, subnet, dns1, dns2);
	WiFi.begin(wifiNetwork, wifiPassword);

	while (WiFi.status() != WL_CONNECTED) {
		digitalWrite(D4, LOW);
		delay(125);
		digitalWrite(D4, HIGH);
		delay(125);
		digitalWrite(D4, LOW);
		delay(125);
		digitalWrite(D4, HIGH);
		delay(125);
	}

	if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3c)) { // Address 0x3D for 128x64
		webLog.println("SSD1306 allocation failed");
		//for (;;); // Don't proceed, loop forever
	}
	else {
		webLog.println("lcd screen started");
		display.display();

		// Clear the buffer
		display.clearDisplay();

		// Draw a single pixel in white
		display.drawPixel(10, 10, WHITE);

		// Show the display buffer on the screen. You MUST call display() after
		// drawing commands to make them visible on screen!
		display.display();

	}
	SetupOTA("TempSend-ESP8235");
	ArduinoOTA.onStart([]() {
		display.clearDisplay();
		display.setTextSize(2);             // Normal 1:1 pixel scale
		display.setTextColor(WHITE);        // Draw white text
		display.setCursor(0, 0);             // Start at top-left corner
		display.print("OTA UPLOADING");
		display.display();

	});
	
	ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
		display.clearDisplay();
		display.setTextSize(2);             // Normal 1:1 pixel scale
		display.setTextColor(WHITE);        // Draw white text
		display.setCursor(0, 0);             // Start at top-left corner
		display.println("UPLOADING");
		display.printf("%3.1f", (progress / (total / 100.0f)));
		display.display();

		Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
	});


	display.clearDisplay();
	display.drawBitmap(0, 0, BBCProductions2, 128, 64, 1);
	display.display();
	
	for (int i = 0; i < 200; i++) {
		ArduinoOTA.handle();
		delay(10);
	}
	for (int i = 0; i < 100; i++) {
		display.clearDisplay();
		display.drawBitmap(-1 + (i%4), 0, BBCProductions2, 128, 64, 1);
		display.display();
	}



	// Start the server
	server.begin();
	webLog.println("Server started:");

	mcpInside.readSensor();
	lastTemp = mcpInside.getTemperature_F();


	netTime.Init(DEVICE_TZ);
	lastTime = millis() - 5000;
	
	udp.begin(3000);


}


volatile unsigned long lastRPMTime = 0;
/*
void ICACHE_RAM_ATTR ISR_FanRPM() {
	float val;
	unsigned long nowish = millis();
	unsigned long diff = nowish - lastRPMTime;
	if (diff > 0) {
		val = 60000.0 / (nowish - lastRPMTime);
		fanRPM = (fanRPM + val) / 2.0;
	}
	lastRPMTime = nowish;
}*/

WiFiClient *tempClient = NULL;


IPAddress IPMainUnit = IPAddress(192, 168, 89, 101);



bool first = true;
bool other = true;
void loop() {
	char buffer[80];
	char webBuffer[120];

	//For reprogramming
	ArduinoOTA.handle();
	//Lets us know the program is running.......
	digitalWrite(D4, !digitalRead(D4));

	netTime.process();

	int packetSize = udp.parsePacket();
	if (packetSize) {
		while (1) {
			char name[40], colon[4], value[40];
			float level = 0.0f;
			if (udp.available() == 0) break;
			size_t sz = udp.readBytesUntil('\n', webBuffer, 120);
			if (sz == 0) break;
			webBuffer[sz] = 0;
			webLog.println(webBuffer);
			//look for the line we want.
			char *ptr;
			int res = sscanf(webBuffer, "%s %s %s", name, colon, value);
			if (res == 3) {
				if (strcmp(name, "\"Water\"") == 0) {
					lastWater = strtof(value, &ptr);
				}
			}
			if (res == 3) {
				if (strcmp(name, "\"LastOutTemp\"") == 0) {
					lastOutTemp = strtof(value, &ptr);
				}
			}
			if (res == 3) {
				if (strcmp(name, "\"Pump\"") == 0) {
					pump = (strstr(value, "false") == NULL);
				}
			}
			if (res == 3) {
				if (strcmp(name, "\"Fan\"") == 0) {
					fan = (strstr(value, "false") == NULL);
				}
			}
			if (res == 3) {
				if (strcmp(name, "\"fanRPM\"") == 0) {
					lastFanRPM = strtof(value, &ptr);
				}
			}

			//Pump and Fan
		}
	}

	//Every 10 seconds
	if (first || ((millis() - lastTime) > 5000)) {
		first = false;
		lastTime = millis();

		char buffer[80];

		int len = 0;

		mcpInside.readSensor();
		lastTemp = mcpInside.getTemperature_F();
		sprintf(buffer, "1,%.1f\n", lastTemp);
		other = !other;
	
		len = strlen(buffer);

		//used to have udp.begin(3000) here............
		udp.beginPacket(IPMainUnit, 3000);
		udp.write(buffer, len + 1);
		udp.endPacket();

		webLog.println(buffer);

		display.clearDisplay();
		display.setTextSize(2);             // Normal 1:1 pixel scale
		display.setTextColor(WHITE);        // Draw white text
		display.setCursor(0, 0);             // Start at top-left corner

		sprintf(buffer, " In:%.1fF", lastTemp);
		display.println(buffer);
		sprintf(buffer, "Out:%.1fF", lastOutTemp);
		display.println(buffer);
		sprintf(buffer, "%.1f Gal", lastWater);
		display.println(buffer);
		if (other) {
			sprintf(buffer, "F:%s P:%s", fan ? "X" : "_", pump ? "X" : "_");
		}
		else {
			sprintf(buffer, "RPM: %.1f", lastFanRPM);
		}
		display.println(buffer);

		display.display();

		WiFiClient wclient;

		wclient.setTimeout(125);
		/*
		if (wclient.connect(IPMainUnit, 80))
		{
			char webBuffer[120];
			String url = "/testas.php";
			wclient.print("GET /data.json HTTP/1.1\r\n");
			wclient.print("Host: 192.168.89.101\r\n");
			wclient.print("Connection: close\r\n");
			wclient.print("\r\n");
			
			delay(50);
			while (!wclient.connected())
			{
				char name[40], colon[4], value[40];
				float level = 0.0f;
				ReadResult rr = readBytesUntil(wclient, webBuffer, '\n', 120, 250);
				webLog.println(webBuffer);
				//look for the line we want.
				char *ptr;
				int res = sscanf(webBuffer, "%s %s %s", name, colon, value);
				if (res == 3) {
					if (strcmp(name, "\"Water\"") == 0) {
						lastWater = strtof(value,&ptr);
					}
				}
				if (res == 3) {
					if (strcmp(name, "\"LastOutTemp\"") == 0) {
						lastOutTemp = strtof(value, &ptr);
					}
				}
				if (res == 3) {
					if (strcmp(name, "\"Pump\"") == 0) {
						pump = (strstr(value, "false") == NULL);
					}
				}
				if (res == 3) {
					if (strcmp(name, "\"Fan\"") == 0) {
						fan = (strstr(value, "false") == NULL);
					}
				}
				//Pump and Fan
			}
			Serial.println("\n[Disconnected]");
		}*/
	}

	//Loop out if we lose WiFi
	while (WiFi.status() != WL_CONNECTED) {
		delay(50);
	}

	/* Everything else after this is the website, so all fucntions have to be above*/

	WiFiClient client = server.available();

	int lps = 0;

	if (!client) return;
	while (client == NULL)
	{
		if (lps > 100) return;  //Skip wifi stuff.
		delay(1);
		client = server.available();
		lps++;
	}

	// Wait until the client sends some data


	while (client.connected() && !client.available())
	{
		delay(1);
		lps++;
		if (lps > 200) return;  //Skip wifi stuff.
	}


	//Bail out, something failed.
	if (!client.connected()) return;



	// Read the first line of the request
	char request[160];
	size_t bytes = client.readBytesUntil('\r', request, 160); // as readBytes with terminator character
															  //	String request = client.readStringUntil('\r');

	client.flush();
	if (!client.connected()) return;

	// Match the request
	int value = LOW;
	do {
		if (strstr(request, "/data.json")) {
			printHeader(client, "application/json");
			client.println("{");
			client.printf(" \"Temp\": %.1f\n", lastTemp);
			client.println("}");
			break;
		}
		if (strstr(request, "/log")) {
			printHeader(client, "text/html");
			tempClient = &client;
			webLog.PrintReverse(clientPrint);
			tempClient = NULL;
			break;
		}
		// Return the response
		printHeader(client, "text/html");
		tempClient = &client;
		outputSite(clientPrint);
		tempClient = NULL;

	} while (0);
	client.flush();
	delay(5);
}

void website_log(WiFiClient c) {
	tempClient = &c;
	printHeader(c, "text/html");
	webLog.PrintReverse([](const char *d) {
		tempClient->println(d);
	});
	tempClient = NULL;
}

///ctype:  application/json : text/html 
void printHeader(WiFiClient client, const char *ctype) {
	//application / json
	client.println(("HTTP/1.1 200 OK"));
	client.print(("Content-Type: "));
	client.print(ctype);
	client.println(F("; charset = UTF-8"));
	client.println("");
}

void clientPrint(const char *data) {
	tempClient->println(data);
}


